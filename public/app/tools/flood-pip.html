<!--
  File: public/app/tools/flood-pip.html
  機能: 洪水浸水想定区域（A31a, 2024, 広島）GeoJSON
        /app/datasets/hazard/flood/hiroshima/flood_2024_river.geojson
        を読み込み、任意の座標 [lon, lat] に対して PIP（Point-in-Polygon）で
        「該当する想定浸水区域」を一覧表示（地図なし・検証用）。
  注意: fetch を使うため file:// 直開き不可。HTTP 配信（プレビュー/本番）でご確認ください。
        データ件数が多いため初回ロードに数秒かかります（端末性能に依存）。
-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>洪水ハザード PIP チェック（広島・検証用）</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; margin: 24px; }
    h1 { margin: 0 0 8px; }
    .muted { color: #666; font-size: 12px; }
    .card { border: 1px solid #ccc; border-radius: 12px; padding: 16px; max-width: 1200px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: end; }
    label { display:block; font-size: 12px; margin-bottom: 4px; }
    input { padding: 8px; border-radius: 8px; border: 1px solid #bbb; min-width: 160px; }
    input[type="number"] { width: 180px; }
    button { padding: 10px 16px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #2563eb; color: white; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 12px; }
    @media (min-width: 1000px) { .grid { grid-template-columns: 1fr 1fr; } }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: rgba(37,99,235,.08); }
    .right { text-align: right; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #059669; }
    .warn { color: #b45309; }
    .spinner { display:inline-block; width:1em; height:1em; border:2px solid #999; border-top-color:transparent; border-radius:50%; animation:spin .9s linear infinite; vertical-align:middle; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .chips { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:6px; }
    .chip { padding:4px 8px; border-radius: 999px; background: rgba(0,0,0,.07); cursor: pointer; }
    details { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>洪水ハザード PIP チェック（広島・検証用）</h1>
  <p class="muted">
    データ: <span class="mono">/app/datasets/hazard/flood/hiroshima/flood_2024_river.geojson</span><br>
    使い方: 経度・緯度を入れて「判定」。該当する想定浸水区域の属性を一覧表示します。
  </p>

  <div class="card">
    <div class="row">
      <div>
        <label>経度（lon）</label>
        <input id="lon" type="number" step="0.000001" placeholder="132.452300" />
      </div>
      <div>
        <label>緯度（lat）</label>
        <input id="lat" type="number" step="0.000001" placeholder="34.392900" />
      </div>
      <div>
        <label>最大表示件数</label>
        <input id="limit" type="number" min="1" max="1000" value="50" />
      </div>
      <div>
        <button id="btn" class="primary">この地点で判定</button>
      </div>
    </div>

    <div class="chips">
      <span class="chip" data-lon="132.4596" data-lat="34.4089">広島駅付近</span>
      <span class="chip" data-lon="132.4523" data-lat="34.3929">平和記念公園付近</span>
      <span class="chip" data-lon="132.6191" data-lat="34.3723">海田町役場付近</span>
    </div>

    <p id="status" class="muted"></p>

    <div class="grid">
      <div>
        <h3>結果（該当区域リスト）</h3>
        <div id="tableWrap"></div>
      </div>
      <div>
        <h3>サマリー</h3>
        <div id="summary"></div>
        <button id="btnExport">該当区域をGeoJSONで保存</button>
        <p class="muted">※ ブラウザで生成した GeoJSON をダウンロードします。</p>
      </div>
    </div>

    <details>
      <summary>技術メモ / 免責</summary>
      <ul>
        <li>このページは検証用です。行政手続等の判断には、公式ハザードマップ等の原典をご確認ください。</li>
        <li>座標は WGS84（GeoJSON 標準）。データは JGD2011 による公開ですが、今回のGML→GeoJSON変換は緯度経度をそのまま用いています。</li>
        <li>PIPは外環と穴（内環）に対応。広域データのため初回ロードが重めです（軽量化は別ステップで行えます）。</li>
      </ul>
    </details>
  </div>

  <script>
    const DATA_URL = "/app/datasets/hazard/flood/hiroshima/flood_2024_river.geojson";
    const GRID_DEG = 0.02; // おおよそ ~2km グリッド。必要に応じて 0.01 に調整。

    const $ = (s)=>document.querySelector(s);
    const statusEl = $("#status");
    const tableWrap = $("#tableWrap");
    const summaryEl = $("#summary");

    // プリセット座標クリック
    document.querySelectorAll(".chip").forEach(el=>{
      el.addEventListener("click", ()=>{
        $("#lon").value = el.getAttribute("data-lon");
        $("#lat").value = el.getAttribute("data-lat");
      });
    });

    // ---- 読み込み＆索引化 ----
    const Flood = {
      loaded:false,
      items:[],       // {bbox:[minX,minY,maxX,maxY], polys:[ [outer,[hole...]]* ], props}
      grid:new Map(), // "gy_gx" -> indices
      async load(){
        if (this.loaded) return this.items.length;
        statusEl.innerHTML = '<span class="spinner"></span> データ読み込み中…（初回のみ）';
        const res = await fetch(DATA_URL, { cache:"force-cache" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const gj = await res.json();
        const feats = Array.isArray(gj.features) ? gj.features : [];

        // 形状を正規化＆索引用に軽量化
        for (const f of feats) {
          const g = f.geometry;
          if (!g || (g.type!=="Polygon" && g.type!=="MultiPolygon")) continue;
          const polys = [];
          if (g.type === "Polygon") {
            polys.push(normalizePolygon(g.coordinates));
          } else {
            for (const p of g.coordinates) polys.push(normalizePolygon(p));
          }
          const bbox = bboxOfPolys(polys);
          const props = f.properties || {};
          const rec = { bbox, polys, props };
          const idx = this.items.length;
          this.items.push(rec);

          // グリッド登録（BBoxが跨るセルすべてに入れる）
          const gx0 = gridX(bbox[0]), gy0 = gridY(bbox[1]);
          const gx1 = gridX(bbox[2]), gy1 = gridY(bbox[3]);
          for (let gy=gy0; gy<=gy1; gy++){
            for (let gx=gx0; gx<=gx1; gx++){
              const key = gy+"_"+gx;
              if (!this.grid.has(key)) this.grid.set(key, []);
              this.grid.get(key).push(idx);
            }
          }
        }
        this.loaded = true;
        statusEl.textContent = `読み込み完了：${this.items.length.toLocaleString()} ポリゴン`;
        return this.items.length;
      },
      queryPoint(lon, lat, limit=50){
        if (!this.loaded) throw new Error("Flood.load() を先に実行してください。");
        const gx0 = gridX(lon), gy0 = gridY(lat);
        const visited = new Set();
        const candIdx = new Set();

        // 近傍セルから候補収集：周囲2セルまで（必要に応じ拡張）
        for (let r=0; r<=2; r++){
          for (let dy=-r; dy<=r; dy++){
            for (let dx=-r; dx<=r; dx++){
              if (Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
              const key = (gy0+dy)+"_"+(gx0+dx);
              if (visited.has(key)) continue;
              visited.add(key);
              const arr = this.grid.get(key);
              if (arr) arr.forEach(i=>candIdx.add(i));
            }
          }
        }

        const results = [];
        for (const i of candIdx){
          const it = this.items[i];
          if (!inBBox(lon, lat, it.bbox)) continue;
          if (pointInPolys(lon, lat, it.polys)) {
            results.push(it);
            if (results.length >= limit) break;
          }
        }
        return results;
      }
    };

    // ---- 幾何ユーティリティ ----
    function normalizePolygon(coords){
      // coords = [ outer, hole1, ... ]
      // outer/hole = [ [lon,lat], ... ] ※終点閉合なくてもOKにする
      const fix = (ring)=>{
        if (!ring || ring.length<4) return ring || [];
        const out = ring.map(p=>[+p[0], +p[1]]);
        const a = out[0], b = out[out.length-1];
        if (a[0]!==b[0] || a[1]!==b[1]) out.push([a[0], a[1]]);
        return out;
      };
      return (coords||[]).map(fix).filter(r=>r.length>=4);
    }
    function bboxOfRing(ring){
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of ring){
        const x=p[0], y=p[1];
        if (x<minX) minX=x; if (y<minY) minY=y;
        if (x>maxX) maxX=x; if (y>maxY) maxY=y;
      }
      return [minX,minY,maxX,maxY];
    }
    function bboxOfPolys(polys){
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const poly of polys){
        for (let i=0;i<poly.length;i++){
          const b = bboxOfRing(poly[i]);
          if (b[0]<minX) minX=b[0];
          if (b[1]<minY) minY=b[1];
          if (b[2]>maxX) maxX=b[2];
          if (b[3]>maxY) maxY=b[3];
        }
      }
      return [minX,minY,maxX,maxY];
    }
    function inBBox(x,y,b){ return x>=b[0] && x<=b[2] && y>=b[1] && y<=b[3]; }

    // 偶奇ルール（Ray casting）
    function pointInRing(x, y, ring){
      let inside=false;
      for (let i=0, j=ring.length-1; i<ring.length; j=i++){
        const xi=ring[i][0], yi=ring[i][1];
        const xj=ring[j][0], yj=ring[j][1];
        const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/((yj-yi)||1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointInPolygon(x, y, poly){
      if (!poly || poly.length===0) return false;
      if (!pointInRing(x, y, poly[0])) return false;       // 外環
      for (let i=1;i<poly.length;i++){                     // 穴
        if (pointInRing(x, y, poly[i])) return false;
      }
      return true;
    }
    function pointInPolys(x, y, polys){
      for (const poly of polys){ if (pointInPolygon(x,y,poly)) return true; }
      return false;
    }

    // グリッド
    function gridX(lon){ return Math.floor(lon / GRID_DEG); }
    function gridY(lat){ return Math.floor(lat / GRID_DEG); }

    // 水深の数値抽出（"0.5～3.0m" などから先頭の数値[m]を拾う・見つからなければ null）
    function depthToMeters(v){
      if (v==null) return null;
      const s = String(v);
      const m = s.match(/(\d+(?:\.\d+)?)\s*m/); // "X m"
      if (m) return parseFloat(m[1]);
      const m2 = s.match(/(\d+(?:\.\d+)?)/);   // 数値だけ
      if (m2) return parseFloat(m2[1]);
      return null;
    }

    // ---- 初期ロード ----
    (async ()=>{
      try{
        await Flood.load();
      }catch(e){
        statusEl.textContent = "読み込み失敗: " + e.message;
      }
    })();

    // ---- 実行 ----
    $("#btn").addEventListener("click", ()=>{
      const lon = parseFloat($("#lon").value);
      const lat = parseFloat($("#lat").value);
      const limit = Math.max(1, parseInt($("#limit").value || "50", 10));
      if (!isFinite(lon) || !isFinite(lat)){
        statusEl.textContent = "経度・緯度を数値で入力してください。";
        return;
      }
      statusEl.innerHTML = '<span class="spinner"></span> 判定中…';
      setTimeout(()=>{
        const hits = Flood.queryPoint(lon, lat, limit);
        renderResults(lon, lat, hits);
      }, 10);
    });

    // ---- 表示 ----
    function renderResults(lon, lat, hits){
      statusEl.textContent = hits.length
        ? `該当 ${hits.length} 件（表示上限あり）`
        : "該当なし";

      // サマリー（riverName 集約・水深指標）
      let minDepth = Infinity, maxDepth = -Infinity, withDepth = 0;
      const rivers = new Map(); // riverName -> count
      const rows = hits.map(h=>{
        const p = h.props || {};
        const riverName = p.riverName ?? "";
        const d = depthToMeters(p.waterDepth);
        if (d!=null){ withDepth++; if (d<minDepth) minDepth=d; if (d>maxDepth) maxDepth=d; }
        rivers.set(riverName, (rivers.get(riverName)||0)+1);
        return {
          riverName,
          waterDepth: p.waterDepth ?? "",
          creatingType: p.creatingType ?? "",
          riverManager: p.riverManager ?? "",
          designedStorm: p.designedStorm ?? "",
          designatedDate: p.designatedDate ?? "",
          announcementNumber: p.announcementNumber ?? ""
        };
      });

      const riverList = Array.from(rivers.entries()).sort((a,b)=>b[1]-a[1]).slice(0,12);
      const depthMsg = withDepth
        ? `深さ（推定m）：最小 ${minDepth.toFixed(2)} / 最大 ${maxDepth.toFixed(2)}（抽出 ${withDepth} 件から推定）`
        : "深さ（数値化できず）：原文の waterDepth を確認してください";

      summaryEl.innerHTML = `
        <div class="mono">座標 [lon, lat] = ${lon.toFixed(6)}, ${lat.toFixed(6)}</div>
        <ul>
          <li>該当ポリゴン数：<b>${hits.length}</b></li>
          <li>${depthMsg}</li>
          <li>主な河川（上位）：${
            riverList.length
              ? riverList.map(([name,c])=>`${esc(name||"(名称なし)")}:${c}`).join(" / ")
              : "—"
          }</li>
        </ul>
      `;

      // テーブル
      if (rows.length === 0){ tableWrap.innerHTML = ""; return; }
      const thead = `
        <thead>
          <tr>
            <th>河川名</th>
            <th>想定浸水深（原文）</th>
            <th>作成種別</th>
            <th>管理者</th>
            <th>計画規模</th>
            <th>指定日</th>
            <th>告示番号</th>
          </tr>
        </thead>`;
      const tbody = rows.map(r=>`
        <tr>
          <td>${esc(r.riverName||"")}</td>
          <td>${esc(r.waterDepth||"")}</td>
          <td>${esc(r.creatingType||"")}</td>
          <td>${esc(r.riverManager||"")}</td>
          <td>${esc(r.designedStorm||"")}</td>
          <td class="mono">${esc(r.designatedDate||"")}</td>
          <td class="mono">${esc(r.announcementNumber||"")}</td>
        </tr>
      `).join("");
      tableWrap.innerHTML = `<table>${thead}<tbody>${tbody}</tbody></table>`;

      // エクスポート
      $("#btnExport").onclick = ()=>{
        const gj = {
          type: "FeatureCollection",
          features: hits.map(h=>({
            type:"Feature",
            properties: h.props,
            geometry: polysToGeometry(h.polys)
          }))
        };
        const blob = new Blob([JSON.stringify(gj)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `flood_hits_${lon.toFixed(6)}_${lat.toFixed(6)}.geojson`;
        a.click();
        URL.revokeObjectURL(url);
      };
    }

    function polysToGeometry(polys){
      if (!polys || polys.length===0) return null;
      if (polys.length===1){
        return { type:"Polygon", coordinates: polys[0] };
      }
      return { type:"MultiPolygon", coordinates: polys };
    }

    function esc(s){ return String(s).replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }
  </script>
</body>
</html>
