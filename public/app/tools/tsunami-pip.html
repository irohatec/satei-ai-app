<!--
  File: public/app/tools/tsunami-pip.html
  機能: 津波浸水想定（A40-16, 広島）の .geojson.gz を読み込み、
        任意座標 [lon, lat] に対して PIP 判定（地図なし・検証用）。
  注意: GitHubの25MB制限回避のため、gzip圧縮ファイルをfetch→ブラウザで解凍します。
-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>津波ハザード PIP チェック（広島・検証用 / gzip対応）</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; margin: 24px; }
    h1 { margin: 0 0 8px; }
    .muted { color: #666; font-size: 12px; }
    .card { border: 1px solid #ccc; border-radius: 12px; padding: 16px; max-width: 1200px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: end; }
    label { display:block; font-size: 12px; margin-bottom: 4px; }
    input { padding: 8px; border-radius: 8px; border: 1px solid #bbb; min-width: 160px; }
    input[type="number"] { width: 180px; }
    button { padding: 10px 16px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #2563eb; color: white; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 12px; }
    @media (min-width: 1000px) { .grid { grid-template-columns: 1fr 1fr; } }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: rgba(37,99,235,.08); }
    .right { text-align: right; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #059669; }
    .warn { color: #b45309; }
    .spinner { display:inline-block; width:1em; height:1em; border:2px solid #999; border-top-color:transparent; border-radius:50%; animation:spin .9s linear infinite; vertical-align:middle; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .chips { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:6px; }
    .chip { padding:4px 8px; border-radius: 999px; background: rgba(0,0,0,.07); cursor: pointer; }
    details { margin-top: 10px; }
  </style>
  <!-- ブラウザでgzipを解凍するためのPako（CDN） -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
  <h1>津波ハザード PIP チェック（広島・検証用 / gzip対応）</h1>
  <p class="muted">
    データ: <span class="mono">/app/datasets/hazard/tsunami/hiroshima/tsunami_2016_inundation.geojson.gz</span><br>
    使い方: 経度・緯度を入れて「判定」。該当する津波浸水想定区域（2016）の属性を一覧表示します。
  </p>

  <div class="card">
    <div class="row">
      <div>
        <label>経度（lon）</label>
        <input id="lon" type="number" step="0.000001" placeholder="132.492500" />
      </div>
      <div>
        <label>緯度（lat）</label>
        <input id="lat" type="number" step="0.000001" placeholder="34.350000" />
      </div>
      <div>
        <label>最大表示件数</label>
        <input id="limit" type="number" min="1" max="1000" value="50" />
      </div>
      <div>
        <button id="btn" class="primary">この地点で判定</button>
      </div>
    </div>

    <div class="chips">
      <span class="chip" data-lon="132.4858" data-lat="34.3466">呉市中心部付近</span>
      <span class="chip" data-lon="132.6251" data-lat="34.3624">海田湾北側付近</span>
      <span class="chip" data-lon="132.9957" data-lat="34.3204">三原港付近</span>
    </div>

    <p id="status" class="muted"></p>

    <div class="grid">
      <div>
        <h3>結果（該当区域リスト）</h3>
        <div id="tableWrap"></div>
      </div>
      <div>
        <h3>サマリー</h3>
        <div id="summary"></div>
        <button id="btnExport">該当区域をGeoJSONで保存</button>
        <p class="muted">※ ブラウザで生成した GeoJSON をダウンロードします。</p>
      </div>
    </div>

    <details>
      <summary>技術メモ / 免責</summary>
      <ul>
        <li>このページは検証用UIです。行政判断等には原典のハザードマップをご確認ください。</li>
        <li>25MB制限回避のため .geojson.gz をクライアント解凍しています。</li>
      </ul>
    </details>
  </div>

  <script>
    const DATA_URL_GZ = "/app/datasets/hazard/tsunami/hiroshima/tsunami_2016_inundation.geojson.gz";
    const FALLBACK_JSON = "/app/datasets/hazard/tsunami/hiroshima/tsunami_2016_inundation.geojson"; // 置かない場合は404でもOK
    const GRID_DEG = 0.02;

    const $ = (s)=>document.querySelector(s);
    const statusEl = $("#status");
    const tableWrap = $("#tableWrap");
    const summaryEl = $("#summary");

    document.querySelectorAll(".chip").forEach(el=>{
      el.addEventListener("click", ()=>{
        $("#lon").value = el.getAttribute("data-lon");
        $("#lat").value = el.getAttribute("data-lat");
      });
    });

    async function loadGeoJSON(){
      statusEl.innerHTML = '<span class="spinner"></span> データ読み込み中（gzip展開）…';
      try {
        // 1) .gz を試す
        const r = await fetch(DATA_URL_GZ, { cache:"force-cache" });
        if (r.ok) {
          const arr = new Uint8Array(await r.arrayBuffer());
          const text = new TextDecoder("utf-8").decode(pako.ungzip(arr));
          return JSON.parse(text);
        }
        // 2) フォールバック（未設置なら404でOK）
        const r2 = await fetch(FALLBACK_JSON, { cache:"force-cache" });
        if (!r2.ok) throw new Error("データ取得に失敗: HTTP " + r2.status);
        return await r2.json();
      } catch (e) {
        statusEl.textContent = "読み込み失敗: " + e.message;
        throw e;
      }
    }

    const Tsunami = {
      loaded:false,
      items:[],
      grid:new Map(),
      async load(){
        if (this.loaded) return this.items.length;
        const gj = await loadGeoJSON();
        const feats = Array.isArray(gj.features) ? gj.features : [];
        for (const f of feats){
          const g = f.geometry;
          if (!g || (g.type!=="Polygon" && g.type!=="MultiPolygon")) continue;
          const polys = [];
          if (g.type === "Polygon") polys.push(normalizePolygon(g.coordinates));
          else for (const p of g.coordinates) polys.push(normalizePolygon(p));
          const bbox = bboxOfPolys(polys);
          const p = f.properties || {};
          const rec = {
            bbox, polys,
            props: { A40_001: p.A40_001 ?? "", A40_002: p.A40_002 ?? "", A40_003: p.A40_003 ?? "" }
          };
          const idx = this.items.length;
          this.items.push(rec);
          const gx0 = gridX(bbox[0]), gy0 = gridY(bbox[1]);
          const gx1 = gridX(bbox[2]), gy1 = gridY(bbox[3]);
          for (let gy=gy0; gy<=gy1; gy++){
            for (let gx=gx0; gx<=gx1; gx++){
              const key = gy+"_"+gx;
              if (!this.grid.has(key)) this.grid.set(key, []);
              this.grid.get(key).push(idx);
            }
          }
        }
        this.loaded = true;
        statusEl.textContent = `読み込み完了：${this.items.length.toLocaleString()} ポリゴン`;
        return this.items.length;
      },
      queryPoint(lon, lat, limit=50){
        if (!this.loaded) throw new Error("Tsunami.load() を先に実行してください。");
        const gx0 = gridX(lon), gy0 = gridY(lat);
        const visited = new Set(), candIdx = new Set();
        for (let r=0; r<=2; r++){
          for (let dy=-r; dy<=r; dy++){
            for (let dx=-r; dx<=r; dx++){
              if (Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
              const key = (gy0+dy)+"_"+(gx0+dx);
              if (visited.has(key)) continue;
              visited.add(key);
              const arr = this.grid.get(key);
              if (arr) arr.forEach(i=>candIdx.add(i));
            }
          }
        }
        const hits = [];
        for (const i of candIdx){
          const it = this.items[i];
          if (!inBBox(lon, lat, it.bbox)) continue;
          if (pointInPolys(lon, lat, it.polys)) {
            hits.push(it);
            if (hits.length >= limit) break;
          }
        }
        return hits;
      }
    };

    // 幾何ユーティリティ
    function normalizePolygon(coords){
      const fix = (ring)=>{
        if (!ring || ring.length<4) return [];
        const out = ring.map(p=>[+p[0], +p[1]]);
        const a = out[0], b = out[out.length-1];
        if (a[0]!==b[0] || a[1]!==b[1]) out.push([a[0], a[1]]);
        return out;
      };
      return (coords||[]).map(fix).filter(r=>r.length>=4);
    }
    function bboxOfRing(r){ let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of r){ const x=p[0], y=p[1]; if (x<minX) minX=x; if (y<minY) minY=y; if (x>maxX) maxX=x; if (y>maxY) maxY=y; }
      return [minX,minY,maxX,maxY];
    }
    function bboxOfPolys(polys){
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const poly of polys){
        for (let i=0;i<poly.length;i++){
          const b=bboxOfRing(poly[i]);
          if (b[0]<minX) minX=b[0];
          if (b[1]<minY) minY=b[1];
          if (b[2]>maxX) maxX=b[2];
          if (b[3]>maxY) maxY=b[3];
        }
      }
      return [minX,minY,maxX,maxY];
    }
    function inBBox(x,y,b){ return x>=b[0] && x<=b[2] && y>=b[1] && y<=b[3]; }
    function pointInRing(x,y,ring){ let inside=false;
      for (let i=0,j=ring.length-1;i<ring.length;j=i++){
        const xi=ring[i][0], yi=ring[i][1], xj=ring[j][0], yj=ring[j][1];
        const intersect=((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/((yj-yi)||1e-12) + xi);
        if (intersect) inside=!inside;
      } return inside;
    }
    function pointInPolygon(x,y,poly){
      if (!poly || poly.length===0) return false;
      if (!pointInRing(x,y,poly[0])) return false;
      for (let i=1;i<poly.length;i++){ if (pointInRing(x,y,poly[i])) return false; }
      return true;
    }
    function pointInPolys(x,y,polys){ for (const poly of polys){ if (pointInPolygon(x,y,poly)) return true; } return false; }
    function gridX(lon){ return Math.floor(lon / GRID_DEG); }
    function gridY(lat){ return Math.floor(lat / GRID_DEG); }
    function esc(s){ return String(s).replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

    // 初期ロード
    (async ()=>{
      try{
        await Tsunami.load();
      }catch(e){
        statusEl.textContent = "読み込み失敗: " + e.message;
      }
    })();

    // 実行
    $("#btn").addEventListener("click", ()=>{
      const lon = parseFloat($("#lon").value);
      const lat = parseFloat($("#lat").value);
      const limit = Math.max(1, parseInt($("#limit").value || "50", 10));
      if (!isFinite(lon) || !isFinite(lat)){
        statusEl.textContent = "経度・緯度を数値で入力してください。";
        return;
      }
      statusEl.innerHTML = '<span class="spinner"></span> 判定中…';
      setTimeout(()=>{
        const hits = Tsunami.queryPoint(lon, lat, limit);
        renderResults(lon, lat, hits);
      }, 10);
    });

    function renderResults(lon, lat, hits){
      statusEl.textContent = hits.length ? `該当 ${hits.length} 件（表示上限あり）` : "該当なし";
      let best = {min:0, max:0, label:null};
      const rows = hits.map(h=>{
        const p = h.props;
        const cls = depthClassify(p.A40_003);
        if (cls.label){
          if (cls.max === Infinity || cls.max > best.max || (best.max !== Infinity && cls.min > best.min)) best = cls;
        }
        return { pref: p.A40_001 || "", code: p.A40_002 || "", depth: p.A40_003 || "" };
      });
      summaryEl.innerHTML = `
        <div class="mono">座標 [lon, lat] = ${lon.toFixed(6)}, ${lat.toFixed(6)}</div>
        <ul><li>該当ポリゴン数：<b>${hits.length}</b></li><li>最深クラス（推定）：<b>${best.label || "不明"}</b></li></ul>`;
      if (rows.length === 0){ tableWrap.innerHTML = ""; return; }
      const thead = `<thead><tr><th>都道府県</th><th>県コード</th><th>浸水深区分（A40_003 原文）</th></tr></thead>`;
      const tbody = rows.map(r=>`<tr><td>${esc(r.pref)}</td><td class="mono">${esc(r.code)}</td><td>${esc(r.depth)}</td></tr>`).join("");
      tableWrap.innerHTML = `<table>${thead}<tbody>${tbody}</tbody></table>`;
      $("#btnExport").onclick = ()=>{
        const gj = { type:"FeatureCollection", features: hits.map(h=>({ type:"Feature", properties: h.props, geometry: polysToGeometry(h.polys) })) };
        const blob = new Blob([JSON.stringify(gj)], {type:"application/json"});
        const url = URL.createObjectURL(blob); const a = document.createElement("a");
        a.href = url; a.download = `tsunami_hits_${lon.toFixed(6)}_${lat.toFixed(6)}.geojson`; a.click(); URL.revokeObjectURL(url);
      };
    }
    function polysToGeometry(polys){ if (!polys || polys.length===0) return null; if (polys.length===1) return {type:"Polygon",coordinates:polys[0]}; return {type:"MultiPolygon",coordinates:polys}; }
    function depthClassify(src){
      if (!src) return {min:0, max:0, label:null};
      const s = String(src).replace(/〜/g,'～').replace(/\s/g,'').toLowerCase();
      const m_rng = s.match(/(\d+(?:\.\d+)?)m?以上?～(\d+(?:\.\d+)?)m?未満?/);
      if (m_rng){ const a=parseFloat(m_rng[1]), b=parseFloat(m_rng[2]); const min=Math.min(a,b), max=Math.max(a,b); return {min,max,label:`${min}–${max}m`}; }
      const m_ge = s.match(/(\d+(?:\.\d+)?)m?以上/); if (m_ge){ const v=parseFloat(m_ge[1]); return {min:v, max:Infinity, label:`${v}m以上`}; }
      const m_lt = s.match(/(\d+(?:\.\d+)?)m?未満/); if (m_lt){ const v=parseFloat(m_lt[1]); return {min:0, max:v, label:`0–${v}m`}; }
      const m_eq = s.match(/(\d+(?:\.\d+)?)m?/); if (m_eq){ const v=parseFloat(m_eq[1]); return {min:v, max:v, label:`${v}m`}; }
      return {min:0, max:0, label:null};
    }
  </script>
</body>
</html>
